#	内存管理

> ## 1、为什么要管理内存
>
> ### 注意：垃圾回收的时候，是阻塞式的，在进行垃圾回收的时候会中断代码的执行！
>
> > ### 	—浏览器：
> >
> > > ### 减少浏览器负担（内存占用过大导致浏览器卡顿）
> > >
> > > ### V8引擎：64位下为1.4G   /   32位下为700MB     跟不同浏览器扩容定论 
> > >
> > > > ### 回收算法：
> > > >
> > > > > #### 新生代：64位约为32MB（短时间存活的变量）
> > > > >
> > > > > > ​	标记已死变量 => 清除已死变量 => from与to对换 => to标记已死变量 => 清除to已死变量 => to与from对换 => 循环....
> > > > > >
> > > > > > ​	32MB平分为2两段，from和to两段
> > > > > >
> > > > > > ​	初始变量将会放在from中，to为空
> > > > > >
> > > > > > ​    代码运行过程中，无引用变量回收，form与to对换，form置空，运行中还存活的变量置换到to空间中
> > > > > >
> > > > > > ​	依次交换类推。
> > > >
> > > > > #### 老生代：64位约为1400MB（存活时间较长的变量）
> > > > >
> > > > > > ​	标记已死变量 => 清除已死变量 => 整理磁盘
> > > > > >
> > > > > > ​	为什么要整理磁盘：由于需要连续的储存空间（例如：数组）如果在清除的变量只有一位的空间，则无法储存，需要为新的连续占用空间的变量腾出空间
> > > > >
> > > > > #### 何时触发回收：
> > > > >
> > > > > > #### 1、执行完一次（主线程）代码
> > > > > >
> > > > > > #### 2、内存不够用时
> > > > > >
> > > > > > > #### 1、全局变量：程序执行完毕时回收
> > > > > > >
> > > > > > > #### 2、普通变量：（局部变量）失去引用时回收
> > > > > >
> > > > > > > ```javascript
> > > > > > > var a = 123;
> > > > > > > var b = 1;
> > > > > > > console.log(a);
> > > > > > > setTimeout(() => {
> > > > > > >     b++;
> > > > > > >     console.log(b)
> > > > > > >     //回收一次
> > > > > > > },2000);
> > > > > > > //回收一次
> > > > > > > ```
>
> > ### —NODE：
> >
> > > #### 内存不够时，服务中断
> > >
> > > #### 扩展知识：
> > >
> > > > Node 可以手动触发垃圾回收
> > > >
> > > > ```
> > > > global.gc
> > > > ```
> > > >
> > > > Node端可以设置内存
> > > >
> > > > ```
> > > > 老生代：
> > > > node --max-old-space-size=1700 文件.js 
> > > > 新生代：
> > > > node --max-new-space-size=1024 文件.js
> > > > ```





# 优化建议

### 1.尽量不要定义全局变量，定义了及时手动释放（xxx = null  /  undefined）

### 2.注意闭包的使用

```javascript
function testMemory(){
    var memory = process.memoryUsage().heapUsed;
	console.log(memory / 1024 / 1024 + "mb");
}

var fn = (function(){
    var arr = [];
	return function(){
    	// *** 优化方案：添加限制条件
    	if(arr.length > 4){
       		arr,shift();
    	}
        // ***
        arr,push(new Array(30 * 1024 * 1024);
		testMemory()
    }
})


// 如果此时循环调用（闭包，该for循环外部引用了fn内的局部变量），则会不断引用局部变量，将不会内存回收
for(var i = 0; i < 10; i++){
    fn()
}
```





