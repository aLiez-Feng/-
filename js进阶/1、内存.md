#	内存管理

> ## 1、为什么要管理内存
>
> > ### 	—浏览器：
> >
> > > ### 减少浏览器负担（内存占用过大导致浏览器卡顿）
> > >
> > > ### V8引擎：64位下为1.4G   /   32位下为700MB     跟不同浏览器扩容定论 
> > >
> > > > ### 回收算法：
> > > >
> > > > > #### 新生代：64位约为32MB（短时间存活的变量）
> > > > >
> > > > > > ​	标记已死变量 => 清除已死变量 => from与to对换 => to标记已死变量 => 清除to已死变量 => to与from对换 => 循环....
> > > > > >
> > > > > > ​	32MB平分为2两段，from和to两段
> > > > > >
> > > > > > ​	初始变量将会放在from中，to为空
> > > > > >
> > > > > > ​    代码运行过程中，无引用变量回收，form与to对换，form置空，运行中还存活的变量置换到to空间中
> > > > > >
> > > > > > ​	依次交换类推。
> > > >
> > > > > #### 老生代：64位约为1400MB（存活时间较长的变量）
> > > > >
> > > > > > ​	标记已死变量 => 清除已死变量 => 整理磁盘
> > > > > >
> > > > > > ​	为什么要整理磁盘：由于需要连续的储存空间（例如：数组）如果在清除的变量只有一位的空间，则无法储存，需要为新的连续占用空间的变量腾出空间
> > > > >
> > > > > #### 何时触发回收：
> > > > >
> > > > > > #### 1、执行完一次（主线程）代码
> > > > > >
> > > > > > #### 2、内存不够用时
> > > > > >
> > > > > > > #### 1、全局变量：程序执行完毕时回收
> > > > > > >
> > > > > > > #### 2、普通变量：（局部变量）失去引用时回收
> > > > > >
> > > > > > > ```javascript
> > > > > > > var a = 123;
> > > > > > > var b = 1;
> > > > > > > console.log(a);
> > > > > > > setTimeout(() => {
> > > > > > >     b++;
> > > > > > >     console.log(b)
> > > > > > >     //回收一次
> > > > > > > },2000);
> > > > > > > //回收一次
> > > > > > > ```
>
> > ### —NODE：
> >
> > > #### 内存不够时，服务中断

