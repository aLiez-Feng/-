# Generator函数及其异步的应用

* ## 线程：

​			线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

​			一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务

​			抢夺式多任务调度...

* ## 协程：

​			 协程是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做`[用户空间线程]`，具有对内核来说不可见的特性。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程（是一种用户实现的非抢夺性的架构）

 

* ## 协程的Generator函数的实现

  * **yield 关键字用来暂停和恢复一个生成器函数(function* 或遗留的生成器函数）。**

  * **generator可以暂停/恢复执行异步任务 （封装异步任务）**

    * yield是ES6的新关键字，使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。

      yield关键字实际返回一个 Iterator Result（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。

      yield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。

  ```javascript
  * 函数体外的数据交换
  let newGen = gen(1); // gen函数体会向外部传输数据，第一次调用next()则为3
  // generator函数返回的是一个指针对象
  
  // generator函数不会执行内部代码，若要执行必须调用 next() 方法
  // 当调用了next方法就会执行generator函数的指针
  console.log(newGen.next()); // {value:3,done,false} 执行let y = yield x + 2;（第一阶段）
  // done为false则表示阶段未完全执行完
  console.log(newGen.next()); // {value:undefined,done:true} 执行 return y; （第二阶段）
  // 为什么此处value会为undefined
  // 由于next调用取的值是gen传入的实参由于第二次没有传入参数则为undefined
  // done为true ，则表示generator所有阶段都执行完毕
  
  console.log(newGen.next(2)); // {value:2,done:true} 执行 return y; （第二阶段传入2）
  
  // 在第一次调用next方法时，不需要传入参数。因为let y = yield x + 2;则为第一阶段
  	// 在第一次调用时，返回的是3，
  // 这里第二次调用next方法传入2，为什么value会为2：
  	// 在第二次调用时，传入的2，会把上一个阶段，也就是第一阶段的返回值2给y，则返回return的是2
  
  
  * 错误处理机制 (try catch)
  function* gen2(x) {
    try {
      var y = yield x + 2;
    } catch (e) {
      console.log(e); // "错误!"
    }
    return y;
  }
  
  let newGen2 = gen2(1);
  
  console.log(newGen2.next()); //{done:false,value}
  newGen2.throw("错误！");
  
  
  function* gen(x) {
    let y = yield x + 2; //yield划分为第一阶段
    return y; // yield划分为第二阶段
  }
  ```

  ## 异步任务封装

  ```javascript
  // 异步任务封装
  var fetch = require("node-fetch");
  
  function* request_gen() {
    var url = "http://xxxxx.com";
    var result = yield fetch(url); //返回的是一个Promise对象
    console.log(result.xxx);
  }
  
  var g = request_gen(); //request_gen调用generator函数获取指针
  var result = g.next(); //执行第一阶段，返回对象
  
  result.value // 获取Promise对象
    .then(function (data) {
      //调用then方法 获取data
      return data.json(); // 转换为json
    })
    .then(function (data) {
      g.next(data); //data作为第一阶段的返回值传入到 console.log(result.xxx);
    });
  
  
  问题：
  	未知什么时候执行第一阶段任务，什么时候执行第二阶段的任务，需要自动去管理
  ```

  

