# 防抖和节流

* ## 防抖

> ### 为什么要做防抖
>
> ```javascript
> 有的操作是高频触发的，但根据需求其实只需要触发一次即可
> 例如：
> 	监听页面窗口resize事件，不需要在拖动窗口大小时，一直触发resize事件
> 	输入框输入，不需要每按一次按钮就去触发，直到用户输入完一段以后再触发
> 理想情况：等用户高频事件完了以后再执行事件操作
> 
> 1、防抖思路
> 事件触发 => 开启一个定时器 => 如果再次触发，则清除上一次定时器，重开定时 => 定时到，触发操作
> 实现：
> function debounce(fn,delay){
>     let timer = null
>     return function(){
>         clearTimeout(timer)
>         timer = setTimeout(() => {
>             fn.apply(fn,arguments)
>         },delay)
>     }
> }
> ```

* ## 节流

  > ### 为什么要节流
  >
  > ```javascript
  > 防抖会一直等到用户完成操作后一段再进行操作，如果一直操作则不会触发
  > 节流为了解决这个问题
  > 例如：
  > 	用户点击发送求，如果一直点请求会一直发不出去
  > 	节流才是正确的思路
  > 		当用户第一次点击以后就发送，直到上一个请求发送成功返回后，才能再次发送
  > 		
  > 		当用户需要在输入的途中请求结果
  > 1、思路：
  > 	某个操作希望上一次完成后再进行下一次，或者说希望每隔一段时间触发一次
  > 	
  > 	事件触发 => 操作执行 => 关闭阀门 => 阀门关闭，后续触发无效 => 一定时间后，阀门打开 => 操作可再次执行
  > 
  > 2、 
  > ```

* # 总结

  * #### 防抖和节流相同点

    * 防抖和节流都是为了阻止操作高频触发，从而浪费性能

  * #### 防抖和节流的区别

    * 防抖：多次触发，指定时间 > 只生效最后一次 （**只需要用户完全操作完以后触发一次**）
    * 节流：每隔一段指定时间只能能触发一次（**需要多次触发的场景**）

